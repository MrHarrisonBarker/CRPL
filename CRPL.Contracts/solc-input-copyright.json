{
    "language": "Solidity",
    "sources": {
        "./contracts/Copyrights/Copyright.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CopyrightBase.sol\";\nimport \"../Utils/IdCounters.sol\";\n\n/// @dev Implementation of a traditional copyright contract using CopyrightBase\ncontract Copyright is CopyrightBase {\n    using IdCounters for IdCounters.IdCounter;\n\n    constructor() CopyrightBase(\"CRPL COPYRIGHT BACKED BY PIPO\") payable {}\n}"
        },
        "./contracts/Copyrights/CopyrightBase.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ICopyright.sol\";\nimport \"../Structs/OwnershipStake.sol\";\nimport \"../Structs/ProposalVote.sol\";\nimport \"../Utils/IdCounters.sol\";\nimport \"../ICopyrightMeta.sol\";\nimport \"../Structs/Meta.sol\";\n\nabstract contract CopyrightBase is ICopyrightMeta {\n    using IdCounters for IdCounters.IdCounter;\n\n    bool internal _locked;\n    string internal _name;\n\n    string constant INVALID_ADDR = \"INVALID_ADDR\";\n    string constant NOT_SHAREHOLDER = \"NOT_SHAREHOLDER\";\n    string constant THREAD_LOCKED = \"THREAD_LOCKED\";\n    string constant NOT_ALLOWED = \"NOT_ALLOWED\";\n    string constant NOT_APPROVED = \"NOT_APPROVED\";\n    string constant NOT_VALID_RIGHT = \"NOT_VALID_RIGHT\";\n    string constant INVALID_SHARE = \"INVALID_SHARE\";\n    string constant NO_SHAREHOLDERS = \"NO_SHAREHOLDERS\";\n    string constant ALREADY_VOTED = \"ALREADY_VOTED\";\n    string constant EXPIRED = \"EXPIRED\";\n\n    // rightId -> ownership structures\n    mapping (uint256 => OwnershipStructure) internal _shareholders;\n    \n    // rightId -> metadata\n    mapping(uint256 => Meta) internal _metadata;\n\n    // owner -> number of copyrights\n    mapping (address => uint256) internal _numOfRights;\n\n    // rightId -> new ownership\n    mapping (uint256 => OwnershipStructure) internal _newHolders;\n\n    // rightId -> shareholder -> bool (prop vote)\n    mapping (uint256 => ProposalVote[]) internal _proposalVotes;\n\n    // rightId -> number of votes\n    mapping (uint256 => uint256) internal _numOfPropVotes;\n\n    // rightId -> approved address\n    mapping (uint256 => address) internal _approvedAddress;\n\n    // owner address -> (operator address -> approved)\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\n\n    IdCounters.IdCounter internal _copyCount;\n\n    constructor(string memory name) {\n        _name = name;\n    }\n\n    function OwnershipOf(uint256 rightId) public override validId(rightId) isExpired(rightId) view returns (OwnershipStake[] memory) {\n        return _mapToOwnershipStakes(_shareholders[rightId]);\n    }\n\n    function PortfolioSize(address owner) external override validAddress(owner) view returns (uint256) {\n        return _numOfRights[owner];\n    }\n\n    function CopyrightMeta(uint256 rightId) public override validId(rightId) isExpired(rightId) view returns (Meta memory) \n    {\n        return _metadata[rightId];\n    }\n\n    function Register(OwnershipStake[] memory to, Meta memory meta) public validShareholders(to) {\n\n        uint256 rightId = _copyCount.next();\n\n        // registering copyright across all shareholders\n        for (uint256 i = 0; i < to.length; i++) {\n\n            require(to[i].share > 0, INVALID_SHARE);\n\n            _recordRight(to[i].owner);\n            _shareholders[rightId].stakes.push(to[i]);\n        }\n        \n        _metadata[rightId] = meta;\n        _shareholders[rightId].exists = true;\n        \n        _approvedAddress[_copyCount.getCurrent()] = msg.sender;\n\n        emit Registered(rightId, to);\n        emit Approved(rightId, msg.sender);\n    }\n\n    function ProposeRestructure(uint256 rightId, OwnershipStake[] memory restructured) external override validId(rightId) isExpired(rightId) validShareholders(restructured) isShareholderOrApproved(rightId, msg.sender) payable {\n        \n        for (uint256 i = 0; i < restructured.length; i++) {\n\n            require(restructured[i].share > 0, INVALID_SHARE);\n\n            _newHolders[rightId].stakes.push(restructured[i]);\n            _newHolders[rightId].exists = true;\n        }   \n\n        emit ProposedRestructure(rightId, _getProposedRestructure(rightId));\n    }\n\n    function Proposal(uint256 rightId) external override validId(rightId) isExpired(rightId) view returns (RestructureProposal memory) {\n        return _getProposedRestructure(rightId);\n    }\n\n    function CurrentVotes(uint256 rightId) external override validId(rightId) isExpired(rightId) view returns (ProposalVote[] memory) {\n        return _proposalVotes[rightId];\n    }\n\n    function BindRestructure(uint256 rightId, bool accepted) external override validId(rightId) isExpired(rightId) isShareholderOrApproved(rightId, msg.sender) payable \n    {\n        _checkHasVoted(rightId, msg.sender);\n     \n        // record vote\n        _proposalVotes[rightId].push(ProposalVote(msg.sender, accepted));\n        _numOfPropVotes[rightId] ++;\n\n        for (uint256 i = 0; i < _proposalVotes[rightId].length; i ++) \n        {\n            if (!_proposalVotes[rightId][i].accepted) \n            {\n                _resetProposal(rightId);\n                emit FailedProposal(rightId);\n\n                return;\n            }\n        }\n\n        // if the proposal has enough votes, **** 100% SHAREHOLDER CONSENSUS ****\n        if (_numOfPropVotes[rightId] == _numberOfShareholder(rightId)) {\n            \n            // proposal has been accepted and is now binding\n\n            OwnershipStake[] memory oldOwnership = OwnershipOf(rightId);\n            \n            // reset has to happen before new shareholders are registered to remove data concerning old shareholders\n            _resetProposal(rightId);\n\n            _shareholders[rightId] = _newHolders[rightId];\n\n            delete(_newHolders[rightId]);\n\n            emit Restructured(rightId, RestructureProposal({oldStructure: oldOwnership, newStructure: OwnershipOf(rightId)}));\n        }\n\n    }\n\n    function ApproveOne(uint256 rightId, address approved) external override validId(rightId) validAddress(approved) isShareholderOrApproved(rightId, msg.sender) payable {\n        // check approved is not owner of copyright\n\n        _approvedAddress[rightId] = approved;\n\n        emit Approved(rightId, approved);\n    }\n\n    function ApproveManager(address manager, bool hasApproval) external override validAddress(manager) {\n        \n        ownerToOperators[msg.sender][manager] = hasApproval;\n\n        emit ApprovedManager(msg.sender, manager, hasApproval);\n    }\n\n    function GetApproved(uint256 rightId) external override validId(rightId) view returns (address) {\n        return _approvedAddress[rightId];\n    }\n\n    function IsManager(address client, address manager) external override view returns (bool) {\n        return ownerToOperators[client][manager];\n    }\n\n    //////////// INTERNAL METHODS ////////////\n\n    function _numberOfShareholder(uint256 rightId) internal view returns (uint256) {\n        return _shareholders[rightId].stakes.length;\n    }\n\n    function _recordRight(address shareholder) internal {\n        _numOfRights[shareholder] += 1;\n    }\n\n    function _getProposedRestructure(uint256 rightId) internal view returns(RestructureProposal memory) {\n        return RestructureProposal({oldStructure: _mapToOwnershipStakes(_shareholders[rightId]), newStructure: _mapToOwnershipStakes(_newHolders[rightId])});\n    }\n    \n    function _mapToOwnershipStakes(OwnershipStructure memory structure) internal pure returns (OwnershipStake[] memory) \n    {\n        OwnershipStake[] memory stakes = new OwnershipStake[](structure.stakes.length);\n        for (uint256 i = 0; i < structure.stakes.length; i++) {\n            stakes[i] = structure.stakes[i];\n        }\n        return stakes;\n    }\n\n    function _resetProposal(uint256 rightId) internal {        \n\n        OwnershipStake[] memory holdersWhoVoted = _shareholders[rightId].stakes;\n\n        for (uint256 i = 0; i < holdersWhoVoted.length; i++) {\n            delete(_proposalVotes[rightId]);\n        }\n\n        _numOfPropVotes[rightId] = 0;\n\n    }\n\n    function _checkHasVoted(uint256 rightId, address addr) internal view\n    {\n        for (uint256 i = 0; i < _proposalVotes[rightId].length; i ++)\n        {\n            require(_proposalVotes[rightId][i].voter != addr, ALREADY_VOTED);\n        }\n    }\n\n    //////////// MODIFIERS ////////////\n\n    modifier isShareholderOrApproved(uint256 rightId, address addr) \n    {\n        uint256 c = 0;\n        for (uint256 i = 0; i < _shareholders[rightId].stakes.length; i++) \n        {\n            if (_shareholders[rightId].stakes[i].owner == addr) c ++;\n        }\n        require(c == 1 || _approvedAddress[rightId] == addr, NOT_SHAREHOLDER);\n        _;\n    }\n\n    modifier validAddress(address addr)\n    {\n        require(addr != address(0), INVALID_ADDR);\n        _;\n    }\n\n    // TODO: could cause a problem\n    modifier validId(uint256 rightId)\n    {\n        require(_shareholders[rightId].exists, NOT_VALID_RIGHT);\n        _;\n    }\n\n    modifier validShareholders(OwnershipStake[] memory holders) \n    {\n        require(holders.length > 0, NO_SHAREHOLDERS);\n\n        for (uint256 i = 0; i < holders.length; i ++) \n        {\n            require(holders[i].owner != address(0), INVALID_ADDR);\n        }\n        _;\n    }\n\n    modifier isExpired(uint256 rightId)\n    {\n        require(_metadata[rightId].expires > block.timestamp, EXPIRED);\n        _;\n    }\n\n    // TODO: atomic locking\n}"
        },
        "./contracts/ICopyright.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Influenced by EIP-712, see: https://eips.ethereum.org/EIPS/eip-721\n\nimport \"./IStructuredOwnership.sol\";\n\n/// @title Basic structure for interfacing with a copyright contract\ninterface ICopyright is IStructuredOwnership {\n\n    /// @dev Emits when a copyright dispute has been registered\n    event Disputed(uint256 indexed rightId, address indexed by, bytes reason);\n\n    /// @dev Emits when a new address is approved to a copyright\n    event Approved(uint256 indexed rightId, address indexed approved);\n\n    /// @dev Emits when a new manager has been approved\n    event ApprovedManager(address indexed owner, address indexed manager, bool hasApproval);\n\n    /// @dev Emits after any modification\n    event Modify(uint256 indexed rightId, bytes modification);\n\n    // @notice gets all the rights held by address\n    /// @param owner portfolios owner address\n    // function Portfolio(address owner) external view returns (uint256[] memory);\n\n    // @notice gets the number of rights held by an address\n    /// @param owner portfolios owner address\n    function PortfolioSize(address owner) external view returns (uint256);\n\n    /// @notice Approve address for the copyright\n    /// @dev Must authorize shareholder\n    /// @param approved Address to be approved\n    /// @param rightId The copyright id\n    function ApproveOne(uint256 rightId, address approved) external payable;\n\n    /// @notice Approve address to be manager of a users whole portfolio\n    /// @dev Must authorize shareholder\n    /// @param manager Address of the new manager\n    /// @param hasApproval If the address has authority\n    function ApproveManager(address manager, bool hasApproval) external;\n\n    /// @notice Gets the approved address for a copyright\n    /// @dev\n    /// @param rightId The copyright id\n    /// @return The approved address\n    function GetApproved(uint256 rightId) external view returns (address);\n\n    /// @notice Asks if address is a manager of a user/clients portfolio\n    /// @dev\n    /// @param client The address of the client in question\n    /// @param manager The address of manager to be checked\n    /// @return If the specific address (manager) has authority for client\n    function IsManager(address client, address manager) external view returns (bool);\n\n    //TODO: Dispute filing, cancelling and resolving\n} \n\n//TODO: Implement EIP-165, see: https://eips.ethereum.org/EIPS/eip-165"
        },
        "./contracts/IStructuredOwnership.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Structs/OwnershipStake.sol\";\nimport \"./Structs/RestructureProposal.sol\";\nimport \"./Structs/ProposalVote.sol\";\n\n/// @title Defintion of a multi party shareholder style ownership structure, with consensus voting\ninterface IStructuredOwnership {\n    \n    /// @dev Emits when a new copyright is registered\n    event Registered(uint256 indexed rightId, OwnershipStake[] to);\n\n    /// @dev Emits when a copyright has been restructured and bound\n    event Restructured(uint256 indexed rightId, RestructureProposal proposal);\n\n    /// @dev Emits when a restructure is proposed\n    event ProposedRestructure(uint256 indexed rightId, RestructureProposal proposal);\n\n    /// @dev Emits when a restructure vote fails\n    event FailedProposal(uint256 indexed rightId);\n\n    /// @notice The current ownership structure of a copyright\n    /// @dev\n    /// @param rightId The copyright id\n    function OwnershipOf(uint256 rightId) external view returns (OwnershipStake[] memory);\n\n    /// @notice Proposes a restructure of the ownership share of a copyright contract, this change must be bound by all share holders\n    /// @dev \n    /// @param rightId The copyright id\n    /// @param restructured The new owernship shares\n    //  @param notes Any notes written concerning restructure for public record\n    function ProposeRestructure(uint256 rightId, OwnershipStake[] memory restructured) external payable;\n\n    /// @notice The current restructure proposal for a copyright\n    /// @dev\n    /// @param rightId The copyright id\n    /// @return A restructure proposal\n    function Proposal(uint256 rightId) external view returns (RestructureProposal memory);\n    \n    function CurrentVotes(uint256 rightId) external view returns (ProposalVote[] memory);\n\n    /// @notice Binds a shareholders vote to a restructure\n    /// @dev Must authorize shareholder\n    /// @param rightId The copyright id\n    /// @param accepted If the shareholder accepts the restructure\n    function BindRestructure(uint256 rightId, bool accepted) external payable;\n}"
        },
        "./contracts/Structs/OwnershipStake.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct OwnershipStake {\n    address owner;\n    uint8 share;\n}\n\nstruct OwnershipStructure {\n    bool exists;\n    OwnershipStake[] stakes;\n}"
        },
        "./contracts/Structs/RestructureProposal.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OwnershipStake.sol\";\n\nstruct RestructureProposal {\n    OwnershipStake[] oldStructure;\n    OwnershipStake[] newStructure;\n}\n"
        },
        "./contracts/Structs/ProposalVote.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct ProposalVote {\n    address voter;\n    bool accepted;\n}"
        },
        "./contracts/Utils/IdCounters.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary IdCounters {\n\n    struct IdCounter {\n        uint256 _count;\n    }\n\n    function getCurrent(IdCounter storage count) internal view returns (uint256) {\n        return count._count;\n    }\n\n    function inc(IdCounter storage count) internal {\n        count._count += 1;\n    }\n\n    function next(IdCounter storage count) internal returns (uint256) {\n        inc(count);\n        return count._count;\n    }\n\n}"
        },
        "./contracts/ICopyrightMeta.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Structs/Meta.sol\";\nimport \"./Structs/Protections.sol\";\nimport \"./ICopyright.sol\";\n\n/// @title Copyright meta and legal data\ninterface ICopyrightMeta is ICopyright {\n    /// @notice all metadata about copyright\n    function CopyrightMeta(uint256 rightId) external view returns (Meta memory);\n}"
        },
        "./contracts/Structs/Meta.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Protections.sol\";\n\nstruct Meta {\n    string title;\n    uint256 expires;\n    uint256 registered;\n    string workHash;\n    string workUri;\n    string legalMeta;\n    string workType;\n    Protections protections;\n}"
        },
        "./contracts/Structs/Protections.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct Protections {\n    bool authorship;\n\n    bool commercialAdaptation;\n    bool nonCommercialAdaptation;\n    \n    bool reviewOrCrit;\n\n    bool commercialPerformance;\n    bool nonCommercialPerformance;\n\n    bool commercialReproduction;\n    bool nonCommercialReproduction;\n    \n    bool commercialDistribution;\n    bool nonCommercialDistribution;\n}"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}